#gcd - нод - найбольший общий делитель
# http://en.wikipedia.org/wiki/Greatest_common_divisor
=begin
Массивы: q - двумерный массив, где q[i] - массив частных qk в цепной дроби a/b=q1+1/(q2+1/q3+1/(...))) Пример: 32/11=2+1/(1+1/10)=[2;1,10]
Примечание: для дальнейшей обработки в q[i] отбрасывается последнее число (для 32/11 q[i]=[2,1])
q_a - массив коээфициентов, получаемых из q[i]. Пример для 32/11: [2,1]=2+1/1=3. Полученное число представлям в виде десятичной дроби: 3/1 или Rational(3,1). Это - есть отношение коэффициентов для пары чисел 32/11, перемножив которые и подобрав знак "минус", получим gcd.
Пример для k1*32+k2*11=gcd=1: -1*32+3*11=1
Для нахождения коэффициентов у многочлена используем цикл for i in 0...array.size-1, где b - n(i+1)-тое число в заданном массиве данных, a- gcd (НОД) для чисел, расположенных до (i+1)-того числа в заданном массиве данных. В первой итерации a = array[0].to_i.abs. В конце каждой итерации a=gcd.
k_array - массив кэффициентов (к-нты Безу), найденные программой и используемые в выводе данных. В начале k_array = [1,1,1,..1]

Пример: k1*32+k2*20+k3*2=gcd
Решение:
Перед циклом: k_array=[1,1,1]
i=0: gcd(32,20)=4; q[i]=32/20=[1,1,1,2] (не записываем в массив последний член, тогда q[i]=[1,1,1]);q_a[i]=1+1/(1+1)=Rational(3,2);
Подставляем коэф-нты, ищем знак "минус"; 2*32-3*20=4.
Заполняем массив коэффициентов: k_array=[2,-3,1]
i=1: gcd(4,2)=2; если числа делятся без остатка (a%b==0): q[i].push(a/b-1). Итого: [4/2-1]=[1]=q[i]; q_a[i]=Rational(q[i][0])=Rational(1,1);
Подставляем коэф-нты, ищем знак "минус"; 1*4-2*2=2.
Заполняем массив коэффициентов: k_array=[2*1,-3*1,-2]=[2,-3,-2]
Цикл завершен. Выводим данные puts log: "2*32+-3*20+-2*1=2"
=end

require 'rational'
#метод, возвращающий gcd (НОД) чисел a и b
def count_gcd(a,b)
a,b=a.abs,b.abs
until a==0:
a,b = b,a if b>a
a=a%b
end
return b
end

#метод, возвращающий целую часть от деления чисел a и b, где c=a%b
def count_koef(a,b,c)
if c==0
return 0
elsif c==a
return 0
else
return (a>b ? a/b : b/a)
end
end

#р - функция, возвращающая (b+1/a)
p = proc {|a,b| (b+Rational(1,a))}

#Блок, отвечающий за ввод данных
puts "Vvedite i0 i1 i2 ... in:"
array = gets
array = array.split.sort.reverse

a = array[0].to_i.abs
q=[]
q_a=[]
k_array=[1]*array.size
for i in 0...array.size-1
	b = array[i+1].to_i.abs
	gcd = count_gcd(a,b)
	
	q[i] = []
	q_a[i] = []
	#c - остаток от деления большего на меньшее в паре чисел а и b
	a>b ? c=a%b : c=b%a
	if c==0	#если числа делятся без остатка, отношением коэффициентов Безу можно считать: (a/b-1)
		if a>b
			q[i].push(a/b-1)
		else
			q[i].push(0, Rational(1,(b/a-1)))
		end
	else 
		aa=a;bb=b
		#Цикл, создающий массив q[i] (не путать с двумерным массивом q), где каждый член массива q[i] - остаток от деления aa/bb.
		while c!=0
			koef = count_koef(aa,bb,c)
			if koef!=0
				q[i].push(koef)
				abc = [aa,bb,c]
				aa=(abc-[abc.max]).max
				bb=(abc-[abc.max]).min
				c=aa%bb
			end
		end
	end
	
	if q[i].size==1 # Если полученный массив q[i] состоит из одного члена, то отношение коэф-нтов равно этому члену
		q_a[i]=Rational(q[i][0])
	else	# иначе (например q[i]=[1,2,3]), расчитываем отношение коэф-нтов по формуле: k1/k2=q1+1/(q2+1/q3+1/(..+1/kn)))/ 
	#Пример: k1/k2=1+1/(2+1/3)=10/7
		q_reverse=q[i].reverse
		qa = q_reverse[0]
		for j in 1...q_reverse.size
			qa=p.call(qa,q_reverse[j])
		end
		q_a[i]=qa
	end
	#if-else блок, отвечающий за правильную позицию а,b,k1,k2 в пропорции a/b=k2/k1
	if a>b	
		k2 = q_a[i].numerator
		k1 = q_a[i].denominator
	else
		k1 = q_a[i].numerator
		k2 = q_a[i].denominator
	end
	#if-else блок, отвечающий за правильную подстановку знака "минус" в формулу k1*a+k2*b=gcd. 
	#Полученные в результате коэф-нты k1 и k2 записываются в массив k_array следующим образом: коэф.-нт для "а"(первого числа в данной итерации или gcd всех предыдущих чисел для цикла for i in 0...array.size-1 в целом) умножается на все члены массива k_array от 0-ого до i-ого включительно; коэф-нт для "b" умножается на k_array[i+1] (по умолчанию 1).
	if (-1)*k1*a+k2*b==gcd
		for k in 0..i
			k_array[k]=-k1*k_array[k]
		end
		k_array[i+1]=k2*k_array[i+1]
	elsif k1*a-k2*b==gcd
		for k in 0..i
			k_array[k]=k1*k_array[k]
		end
		k_array[i+1]=-k2*k_array[i+1]
	else
		puts "error"
	end
	a=gcd
end
#Создание и вывод стринговой переменной log, имеющей вид: "k0*i0+k1*i1+...+kn*in=gcd"
log=""
array.each_with_index{ |ar, index|
	log = log+"#{k_array[index]}*#{ar}"
	index!=(array.size-1) ? log=log+"+" : log=log+"=#{gcd}"
}
puts log
